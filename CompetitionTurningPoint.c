#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sonarDist,      sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           launcherLB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           launcherLT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           launcherRB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           launcherRT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightBackWheel, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           leftBackWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          conveyor,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

// Sets launcher to a given speed
// Left bottom & right top turn clockwise, others counterclockwise
void setLauncherSpeed(int speed){
	motor[launcherLB] = speed;
	motor[launcherRT] = speed;
	motor[launcherRB] = speed;
	motor[launcherLT] = speed;
}

//launches the preloaded ball
void launchOn(){
	//once speed reaches 127 leaves loop and stays
	for(int speed = 37; speed <= 127; speed += 30){
		setLauncherSpeed(speed);
		sleep(31);
	}
}

//sets the speed of the wheels to the variable specified
void stopWheels(){
	motor[leftBackWheel] = 0;
	motor[leftFrontWheel] = 0;
	motor[rightBackWheel] = 0;
	motor[rightFrontWheel] = 0;
}

void setWheelSpeed(int speed){
	motor[leftBackWheel] = speed;
	motor[leftFrontWheel] = speed;
	motor[rightBackWheel] = speed;
	motor[rightFrontWheel] = speed;
}

void setLeftWheels(int speed){
	motor[leftBackWheel] = speed;
	motor[leftFrontWheel] = speed;
}

void setRightWheels(int speed){
	motor[rightBackWheel] = speed;
	motor[rightFrontWheel] = speed;
}

void moveForward(float ticks,int leftSpeed,int rightSpeed){
	resetMotorEncoder(rightBackWheel);
	setLeftWheels(leftSpeed);
	setRightWheels(rightSpeed);
	waitUntil(getMotorEncoder(rightBackWheel) >= ticks);
	setWheelSpeed(0);
}

void moveBackward(float ticks,int leftSpeed,int rightSpeed){
	resetMotorEncoder(rightBackWheel);
	setLeftWheels(leftSpeed);
	setRightWheels(rightSpeed);
	waitUntil(getMotorEncoder(rightBackWheel) <= -(ticks));
	setWheelSpeed(0);
}

//turn on conveyor belt
void setConveyorSpeed(int speed){
	motor[conveyor] = speed;
}

void autonomousLeft(){
	//******** SHOOT BALL ********
	//launch ball
	launchOn();
	//wait 1 second
	sleep(1000);
	//move up conveyor belt
	setConveyorSpeed(-50);
	sleep(2500);
	//stop launcher and conveyor belt
	setLauncherSpeed(0);
	setConveyorSpeed(0);

	//******** MOVE FORWARD ********
	//move forward 1.5 tiles and stop
	moveForward(2100,60,60);

	//******** MOVE BACKWARD ********
	//move backward 24 inches and stop
	moveBackward(2100,-60,-60);
}

void autonomousRight(){
	//******** SHOOT BALL ********
	//launch ball
	launchOn();
	//wait 1 second
	sleep(1000);
	//move up conveyor belt
	setConveyorSpeed(-50);
	sleep(2500);
	//stop launcher and conveyor belt
	setLauncherSpeed(0);
	setConveyorSpeed(0);

	//******** MOVE FORWARD ********
	//move forward 1.5 tiles and stop
	moveForward(2100,80,60);

	//******** MOVE BACKWARD ********
	//move backward 24 inches and stop
	moveBackward(2100,-80,-60);
}

task autonomous()
{
	autonomousRight();
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

//************************************
//**********     WHEELS     **********
//************************************

//https://www.desmos.com/calculator/xv2hbpabjm
int modJoystick(int input){
	return (input+(pow(input,5)/8192-pow(input,3))/8192)/2;
}

//moves the 4 motors controlling the 4 wheels using the signals from the right and left joystick
task updateWheels(){
		motor[leftFrontWheel] = modJoystick(vexRT[Ch3]);
		motor[leftBackWheel] = modJoystick(vexRT[Ch3]);
		motor[rightFrontWheel] = modJoystick(vexRT[Ch2]);
		motor[rightBackWheel] = modJoystick(vexRT[Ch2]);

		sleep(10); // To avoid a hotloop
}


//************************************
//**********    LAUNCHER    **********
//************************************

void launcherNiko(){
	while(motor[launcherLB]!=127){
		motor[launcherLB]+=10;
		motor[launcherLT]+=10;
		motor[launcherRB]+=10;
		motor[launcherRT]+=10;
	}
}

// Press 8U for Jess's, 8R for Cait's, 8D for Exponential
task updateLauncher(){
		// If 8U pressed, do Niko's launcher & wait for the button to be released
		if (vexRT[Btn5U] == 1){
				launcherNiko();
		} else if (vexRT[Btn5D] == 1){
			setLauncherSpeed(0);
		}
}


//************************************
//**********     INTAKE     **********
//************************************

task updateIntake(){
		// Check if button is pressed
		if (vexRT[Btn6U] == 1){
				motor[intake] = -60;
				motor[conveyor] = 60;
		} else if (vexRT[Btn6D] == 1){
				motor[intake] = 60;
				motor[conveyor] = -60;
		} else {
				motor[intake] = 0;
				motor[conveyor] = 0;
		}
}

task updateDisplay(){
	bLCDBacklight = true;					// Turn on LCD Backlight
	//string mainBattery, backupBattery;

	//while(true){									// An infinite loop to keep the program running until you terminate it
		clearLCDLine(0);    				// Clear line 1 (0) of the LCD
		clearLCDLine(1);    				// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		//sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); 	//Build the value to be displayed
		//displayNextLCDString(mainBattery);
		displayLCDNumber(1, 9, nImmediateBatteryLevel/1000.0);
		displayLCDChar(1, 15, 'V');

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		//sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
		//displayNextLCDString(backupBattery);
		displayLCDNumber(1, 8, BackupBatteryLevel/1000.0);
		displayLCDChar(1, 14, 'V');

		//Short delay for the LCD refresh rate
		//wait1Msec(100);
		sleep(10);

	//}
}

task usercontrol()
{
  while (true)
  {
    startTask( updateWheels );
		startTask( updateLauncher );
		startTask( updateIntake );
  }
}
