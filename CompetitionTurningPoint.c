#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sonarDist,      sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           launcherLB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           launcherLT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           launcherRB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           launcherRT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightBackWheel, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           leftBackWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          conveyor,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

bool red = true; //are we on the red team?

// Sets launcher to a given speed
// Left bottom & right top turn clockwise, others counterclockwise
void setLauncherSpeed(int speed){
	motor[launcherLB] = speed;
	motor[launcherRT] = speed;
	motor[launcherRB] = speed;
	motor[launcherLT] = speed;
}

//launches the preloaded ball
void launchOn(){
	//once speed reaches 127 leaves loop and stays
	for(int speed = 37; speed <= 127; speed += 30){
		setLauncherSpeed(speed);
		sleep(31);
	}

	//wait until ball is shot
	//sleep(time);

	//stop
	//setLauncherSpeed(0);
}

//sets the speed of the wheels to the variable specified
void stopWheels(){
	motor[leftBackWheel] = 0;
	motor[leftFrontWheel] = 0;
	motor[rightBackWheel] = 0;
	motor[rightFrontWheel] = 0;
}

//moves robot forward
void moveForward(int time){
	motor[leftBackWheel] = 60;
	motor[leftFrontWheel] = 60;
	motor[rightBackWheel] = 60;
	motor[rightFrontWheel] = 60;
	sleep(time);
	stopWheels();
}

//moves robot backward
void moveBackward(int time){
	motor[leftBackWheel] = -60;
	motor[leftFrontWheel] = -60;
	motor[rightBackWheel] = -60;
	motor[rightFrontWheel] = -60;
	sleep(time);
	stopWheels();
}

//turns the robot left in place
void pivotLeft(int time){
	motor[leftBackWheel] = -60;
	motor[leftFrontWheel] = -60;
	motor[rightBackWheel] = 60;
	motor[rightFrontWheel] = 60;
	sleep(time);
	stopWheels();
}

//turns the robot left in place
void pivotRight(int time){
	motor[leftBackWheel] = 60;
	motor[leftFrontWheel] = 60;
	motor[rightBackWheel] = -60;
	motor[rightFrontWheel] = -60;
	sleep(time);
	stopWheels();
}

//turns left in a circular motion
void carTurnLeft(int time){
	motor[rightBackWheel] = 60;
	motor[rightFrontWheel] = 60;
	sleep(time);
	stopWheels();
}

//turns right in a circular motion
void carTurnRight(int time){
	motor[rightBackWheel] = 60;
	motor[rightFrontWheel] = 60;
	sleep(time);
	stopWheels();
}

//turn on conveyor belt
void setConveyorSpeed(int speed){
	motor[conveyor] = speed;
	motor[intake] = speed;
}

//if we start farther away from the poles while on the red team
void fartherRed(){
}

//if we start farther away from the poles while on the blue team
void fartherBlue(){
}

//if starting closer to the poles while on the red team
void closerRed(){
	carTurnLeft(500);
	pivotLeft(1000);
	stopWheels();
	launchOn();
	sleep(3000);
	setConveyorSpeed(80);
	sleep(1500);
	setConveyorSpeed(0);
	setLauncherSpeed(0);
	moveForward(3000);
	moveBackward(3000);
	pivotRight(1000);
	moveForward(2000);
}

//if starting closer to the poles while on the blue team
void closerBlue(){
	launchOn();
	sleep(1000);
	setConveyorSpeed(-80);
	sleep(1000);
	//setConveyorSpeed(0);
	setLauncherSpeed(0);
	pivotLeft(15);
	moveForward(2000);
	//moveBackward(2000);
	//pivotLeft(1200);
	//moveForward(3000);
}

task autonomous()
{
	closerBlue();
//  if(red){
//  	if(sonarDist>24){
//  		closerRed();
//  	} else{
//  		fartherRed();
//  	}
//  } else{
//  	if(sonarDist>24){
//  		closerBlue();
//  	} else{
//  		fartherBlue();
//  	}
//	}
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

//************************************
//**********     WHEELS     **********
//************************************

bool launcherOn = false;
bool intakeOff = true;
int MAX = 127;

//https://www.desmos.com/calculator/xv2hbpabjm
int modJoystick(int input){
	return (input+(pow(input,5)/8192-pow(input,3))/8192)/2;
}

//moves the 4 motors controlling the 4 wheels using the signals from the right and left joystick
task updateWheels(){
		motor[leftFrontWheel] = modJoystick(vexRT[Ch3]);
		motor[leftBackWheel] = modJoystick(vexRT[Ch3]);
		motor[rightFrontWheel] = modJoystick(vexRT[Ch2]);
		motor[rightBackWheel] = modJoystick(vexRT[Ch2]);

		sleep(10); // To avoid a hotloop
}


//************************************
//**********    LAUNCHER    **********
//************************************


//gradual 37-67-97-127
//takes 124ms
void accLauncherJess(){
	//once speed reaches 127 leaves loop and stays
	for(int speed = 37; speed <= 127; speed += 30){
		setLauncherSpeed(speed);
		sleep(31);
	}
}

//61-84-105-127
//starts larger, smaller increments
//speed = 22x+61 from
//should take 100ms
void accLauncherCait(){
	for(int x = 0; x <= 3; x++){
		setLauncherSpeed(22*x+61);
		//wait 25 milliseconds
		sleep(25);
	}
}

//exponentially increases the launcher speed
//caitlin obrien
//speed = (e^x)-1 from x= 3.1 to x = 5.1
//should take 100ms
void accLauncherExp(){
	for(float x = 3.1; x <= 5.1; x+=.4){
		setLauncherSpeed(exp(x)-1);
		//waits 20 milliseconds
		sleep(20);
	}
}

void launcherNiko(){
	while(motor[launcherLB]!=MAX){
		motor[launcherLB]+=10;
		motor[launcherLT]+=10;
		motor[launcherRB]+=10;
		motor[launcherRT]+=10;

	}
}

// Press 8U for Jess's, 8R for Cait's, 8D for Exponential
task updateLauncher(){
		// If 8U pressed, do Jess's launcher & wait for the button to be released
		if (vexRT[Btn5U] == 1){
			//if(launcherOn){
				//launcherOn = false;
				//setLauncherSpeed(0);
			//} else{
				//launcherOn = true;
				launcherNiko();
			//}

		// If 8R is pressed, do Cait's launcher & wait for the button to be released
		//} else if (vexRT[Btn8R] == 1){
			//accLauncherCait();
			//waitUntil(vexRT[Btn8R] == 0);

		// If 8D is pressed, do Cait's launcher & wait for the button to be released
		} else if (vexRT[Btn5D] == 1){
			setLauncherSpeed(0);
			//accLauncherExp();
			//waitUntil(vexRT[Btn8D] == 0);
		}

		// Otherwise make sure launcher speed is 0
		//} else {
		//	setLauncherSpeed(0);
		//	sleep(10);
		//}
}


//************************************
//**********     INTAKE     **********
//************************************

//bool intakeOff = true;

task updateIntake(){

		// Check if button is pressed
		if (vexRT[Btn6U] == 1){
			//if (intakeOff) {
				// Turn intake on
				//intakeOff = false;

				motor[intake] = -60;
				motor[conveyor] = 60;

			//} else{
				//intakeOff = true;
				//motor[intake] = 0;
				//motor[conveyor] = 0;
			//}
		} else if (vexRT[Btn6D] == 1){
			//if(intakeOff) {
				//intakeOff = false;
				motor[intake] = 60;
				motor[conveyor] = -60;
			//} else{
				//intakeOff = true;
				//motor[intake] = 0;
				//motor[conveyor] = 0;
			//}
		} else {
				// Turn intake off
				//intakeOff = true;

				motor[intake] = 0;
				motor[conveyor] = 0;

			}

			// Wait for button to be released
			//waitUntil(vexRT[Btn7L] == 0);
		//}

		// Sleep so that it's not a "hotloop"
		//sleep(10);
}

task updateDisplay(){
	bLCDBacklight = true;					// Turn on LCD Backlight
	//string mainBattery, backupBattery;

	//while(true){									// An infinite loop to keep the program running until you terminate it
		clearLCDLine(0);    				// Clear line 1 (0) of the LCD
		clearLCDLine(1);    				// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		//sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); 	//Build the value to be displayed
		//displayNextLCDString(mainBattery);
		displayLCDNumber(1, 9, nImmediateBatteryLevel/1000.0);
		displayLCDChar(1, 15, 'V');

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		//sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
		//displayNextLCDString(backupBattery);
		displayLCDNumber(1, 8, BackupBatteryLevel/1000.0);
		displayLCDChar(1, 14, 'V');

		//Short delay for the LCD refresh rate
		//wait1Msec(100);
		sleep(10);

	//}
}

task usercontrol()
{
	clearLCDLine(0);    				// Clear line 1 (0) of the LCD
	clearLCDLine(1);
	displayLCDString(0,0,"UWU");

  while (true)
  {
		//startTask( updateDisplay );
    startTask( updateWheels );
		startTask( updateLauncher );
		startTask( updateIntake );
  }

}
