#pragma config(Motor,  port2,           launcherLB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           launcherLT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           launcherRB,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           launcherRT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftBackWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightBackWheel, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//variables
bool launcherOff = true;

//it needed to be faster so i made a slight alteration
//https://www.desmos.com/calculator/xv2hbpabjm
int modify2(int input){
	return (input+(pow(input,5)/8192-pow(input,3))/8192)/2;
}

void updateWheels(){

}

//gradual 30-65-95-127
void updateLauncherJess(){
	//when the button is being pressed
	while(vexRT[Btn8u]==1){
		//so speed isn’t local and thrown away
		Int speed=0;
		//once speed reaches 127 leaves loop and stays
		for(speed=37; speed <=127; speed+= 30){
			motor[launcherLB]= - (speed);
			motor[launcherLT]= - (speed);
			motor[launcherRB]=speed;
			motor[launcherRT]=speed;
			waitInMilliseconds(31.25);
		}
	}
}

//61-84-105-127
//starts larger, smaller increments
//speed = 22x+61 from
//should take 1 decisecond
void updateLauncherCait(){
	//if button 8R is pressed
	if(vexRT[Btn8R] == 1){
		//if launcher is off, turn on
		if(launcherOff){
			//starts at 61 and accelerates to 127
			for(int x = 0; x <= 3; x++){
				//right top and left bottom motors turn clockwise
				motor[launcherLB] = 22*x+61;
				motor[launcherRT] = 22*x+61;
				//left top and right bottom turn counterclockwise
				motor[launcherRB] = -22*x-61;
				motor[launcherLT] = -22*x-61;
				//wait 25 milliseconds
				waitInMilliseconds(25);
			}
		}
		//if launcher is on, turn off
		else{
			motor[launcherLB] = 0;
			motor[launcherRB] = 0;
			motor[launcherLT] = 0;
			motor[launcherRT] = 0;
		}
	}
}

//exponentially increases the launcher speed
//caitlin obrien
//speed = (e^x)-1 from x= 3.1 to x = 5.1
//should take 1 decisecond
void updateLauncherExponential{
	//if button 8D is pressed
	if(vexRT[Btn8D] == 1){
		//if the launcher is off, turn on
		if(launcherOff){
			//starts at 21 and accelerates to 163
			for(float x = 3.1; x <= 5.1; x+=.4){
				//right top and left bottom motors turn clockwise
				motor[launcherRT] = pow(e,x)-1;
				motor[launcherLB] = pow(e,x)-1;
				//left top and right bottom turn counterclockwise
				motor[launcherLT] = -pow(e,x)-1;
				motor[launcherRB] = -pow(e,x)-1;
				//waits 20 milliseconds
				waitInMilliseconds(20);
			}
		}
		//if the launcher is on, turn off motors
		else{
			motor[launcherLB] = 0;
			motor[launcherRB] = 0;
			motor[launcherLT] = 0;
			motor[launcherRT] = 0;
		}
	}
}

task main()
{
	while(true){
		updateWheels();
		updateLauncherJess();
		updateLauncherCait();
		updateLauncherExponential();
	}

}
